## Задача 1
## Планински масив :mountain:

### Условие

Ще наричаме _планински_ даден масив от цели числа `array`, ако и само ако
  - има поне три елемента
  - съществува елемент на масива, за който е в сила, че
    - всички елементи до него (включително) образуват строго монотонно растяща редица числа
    - всички елементи от него (включително) до края на масива образуват строго монотонно намаляваща редица числа

Създайте публичен клас `ArrayAnalyzer` с метод

```java
public static boolean isMountainArray(int[] array)
```

който по даден масив `array` определя дали той е _планински_.

<img src="https://github.com/fmi/java-course/blob/master/01-intro-to-java/lecture/images/mountain-array.png" style="width: 50%; height: 50%" alt="Mountain array">

### Примери

| Извикване                                | Резултат |
| :--------------------------------------- | :------- |
| `isMountainArray(new int[]{2, 1})`       | `false`  |
| `isMountainArray(new int[]{3, 5, 5})`    | `false`  |
| `isMountainArray(new int[]{0, 3, 2, 1})` | `true`   |

### :warning: Забележки

- Използването на структури от данни, различни от масив, **не е позволено**. Задачата трябва да се реши с помощта на знанията от първата лекция от курса.



## Задача 2

## Прогноза за времето :partly_sunny:

### Условие

В този сезон, лятото вече ни липсва и всеки се чуди, ще има ли скоро някой по-топъл ден.
Разполагаме с прогнозата за следващите дни, под формата на масив от максималните дневни температури като цели числа. Интересуваме се, за всеки конкретен ден, колко дни трябва да чакаме до по-топъл ден. Ако не съществува такъв бъдещ ден, приемаме резултата за 0.

Създайте публичен клас `WeatherForecaster` с метод

```java
public static int[] getsWarmerIn(int[] temperatures)
```

който по даден масив с прогнозни температури `temperatures` връща масив, _i_-тият елемент на който е броят дни до първия следващ ден с по-висока максимална температура.

### Примери

| Извикване                                           | Резултат                   |
| :-------------------------------------------------- | :------------------------- |
| `getsWarmerIn(new int[]{3, 4, 5, 1, -1, 2, 6, 3}))` | `[1, 1, 4, 2, 1, 1, 0, 0]` |
| `getsWarmerIn(new int[]{3, 4, 5, 6}))`              | `[1, 1, 1, 0]`             |
| `getsWarmerIn(new int[]{3, 6, 9}))`                 | `[1, 1, 0]`                |

### :star: Side quest, или допълнително предизвикателство

Можете ли да решите задачата с алгоритъм с линейна сложност (O(N))?

### :warning: Забележки

- Използването на структури от данни, различни от масив, **не е позволено**. Задачата трябва да се реши с помощта на знанията от първата лекция от курса.



## Задача 3

## Каноничен директорен път :file_folder:

### Условие

В Unix-style операционните системи, точката `.` означава текущата директория, двете точки `..` реферират директорията на по-горното ниво, а произволна последователност от наклонени черти (например `//`) се третират като единична наклонена черта (`/`). Приемаме, че всяка друга формация от точки (например `...`) се третира като име на файл или директория.

_Каноничен_ наричаме директорен път,

  - който започва с единична наклонена черта `/`
  - в който всеки две директории са разделени с единична наклонена черта `/`
  - който не завършва с `/`
  - който съдържа само директориите по пътя от корена до дадения файл или директория, т.е. не съдържа `.` или `..`

Създайте публичен клас `PathUtils` с метод

```java
public static String getCanonicalPath(String path)
```

който по даден път връща еквивалентния му _каноничен_ път.

### Примери

| Извикване                             | Резултат      |
| :------------------------------------ | :------------ |
| `getCanonicalPath("/home/")`          | `"/home"`     |
| `getCanonicalPath("/../")`            | `"/"`         |
| `getCanonicalPath("/home//foo/")`     | `"/home/foo"` |
| `getCanonicalPath("/a/./b/../../c/")` | `"/c"`        |

### :warning: Забележки

- Използването на структури от данни, различни от масив, **не е позволено**. Задачата трябва да се реши с помощта на знанията от първата лекция от курса. Това в частност изключва използването на каквито и да е API-та за работа с файловата система.